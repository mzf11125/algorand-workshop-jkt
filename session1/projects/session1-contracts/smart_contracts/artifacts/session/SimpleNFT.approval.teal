#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 8
    bytecblock "total_supply" "current_token_id" "current_owner" 0x151f7c75 "minter" "next_token_id" "token_name" "token_symbol" "token_uri"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/session/contract.py:13-14
    // # Contract metadata
    // self.token_name = String()
    bytec 6 // "token_name"
    pushbytes ""
    app_global_put
    // smart_contracts/session/contract.py:15
    // self.token_symbol = String()
    bytec 7 // "token_symbol"
    pushbytes ""
    app_global_put
    // smart_contracts/session/contract.py:16
    // self.token_uri = String()
    bytec 8 // "token_uri"
    pushbytes ""
    app_global_put
    // smart_contracts/session/contract.py:18-19
    // # NFT management
    // self.total_supply = UInt64()
    bytec_0 // "total_supply"
    intc_0 // 0
    app_global_put
    // smart_contracts/session/contract.py:20
    // self.next_token_id = UInt64(1)  # Start from token ID 1
    bytec 5 // "next_token_id"
    intc_1 // 1
    app_global_put
    // smart_contracts/session/contract.py:22-23
    // # Access control
    // self.minter = Account()
    bytec 4 // "minter"
    global ZeroAddress
    app_global_put
    // smart_contracts/session/contract.py:25-26
    // # Individual token ownership (simplified for single NFT)
    // self.current_owner = Account()
    bytec_2 // "current_owner"
    global ZeroAddress
    app_global_put
    // smart_contracts/session/contract.py:27
    // self.current_token_id = UInt64(0)
    bytec_1 // "current_token_id"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/session/contract.py:5
    // class SimpleNFT(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@19
    pushbytess 0xdd6d3278 0x7f1d43e1 0x9fee7418 0x589bc3fa 0x8a777839 0xcff6577e 0x4294948f 0x06dc5f09 0x05f7d655 0x46909355 0x99ce2ef7 0xe92e8210 0x49699f74 // method "mint(address,string)uint64", method "burn(uint64)void", method "transfer(address,uint64)void", method "transfer_from(address,address,uint64)void", method "balance_of(address)uint64", method "owner_of(uint64)address", method "get_name()string", method "get_symbol()string", method "get_uri(uint64)string", method "get_total_supply()uint64", method "set_minter(address)void", method "get_current_token_id()uint64", method "exists(uint64)bool"
    txna ApplicationArgs 0
    match mint burn transfer transfer_from balance_of owner_of get_name get_symbol get_uri get_total_supply set_minter get_current_token_id exists
    err

main_create_NoOp@19:
    // smart_contracts/session/contract.py:5
    // class SimpleNFT(ARC4Contract):
    pushbytes 0xef7d02fe // method "initialize(string,string,string,address)void"
    txna ApplicationArgs 0
    match initialize
    err


// smart_contracts.session.contract.SimpleNFT.initialize[routing]() -> void:
initialize:
    // smart_contracts/session/contract.py:29
    // @abimethod(allow_actions=["NoOp"], create="require")
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/session/contract.py:34-36
    // # Note: String validation is done by the ARC4 framework
    // # Empty strings will be caught by the framework validation
    // self.token_name = name
    bytec 6 // "token_name"
    uncover 4
    app_global_put
    // smart_contracts/session/contract.py:37
    // self.token_symbol = symbol
    bytec 7 // "token_symbol"
    uncover 3
    app_global_put
    // smart_contracts/session/contract.py:38
    // self.token_uri = uri
    bytec 8 // "token_uri"
    uncover 2
    app_global_put
    // smart_contracts/session/contract.py:39
    // self.minter = minter
    bytec 4 // "minter"
    swap
    app_global_put
    // smart_contracts/session/contract.py:41-42
    // # Initialize counters
    // self.total_supply = UInt64(0)
    bytec_0 // "total_supply"
    intc_0 // 0
    app_global_put
    // smart_contracts/session/contract.py:43
    // self.next_token_id = UInt64(1)
    bytec 5 // "next_token_id"
    intc_1 // 1
    app_global_put
    // smart_contracts/session/contract.py:44
    // self.current_token_id = UInt64(0)
    bytec_1 // "current_token_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/session/contract.py:29
    // @abimethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.mint[routing]() -> void:
mint:
    // smart_contracts/session/contract.py:46
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/session/contract.py:52
    // assert Txn.sender == self.minter, "Only minter can mint NFTs"
    txn Sender
    intc_0 // 0
    bytec 4 // "minter"
    app_global_get_ex
    assert // check self.minter exists
    ==
    assert // Only minter can mint NFTs
    // smart_contracts/session/contract.py:53
    // assert to != Account(), "Cannot mint to zero address"
    dup
    global ZeroAddress
    !=
    assert // Cannot mint to zero address
    // smart_contracts/session/contract.py:56-57
    // # Check if we already have an NFT (for single NFT implementation)
    // assert self.total_supply == UInt64(0), "This contract supports single NFT only"
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    !
    assert // This contract supports single NFT only
    // smart_contracts/session/contract.py:59-60
    // # Assign token ID
    // token_id = self.next_token_id
    intc_0 // 0
    bytec 5 // "next_token_id"
    app_global_get_ex
    assert // check self.next_token_id exists
    // smart_contracts/session/contract.py:62-63
    // # Update state
    // self.current_owner = to
    bytec_2 // "current_owner"
    uncover 2
    app_global_put
    // smart_contracts/session/contract.py:64
    // self.current_token_id = token_id
    bytec_1 // "current_token_id"
    dig 1
    app_global_put
    // smart_contracts/session/contract.py:65
    // self.total_supply = self.total_supply + UInt64(1)
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    intc_1 // 1
    +
    bytec_0 // "total_supply"
    swap
    app_global_put
    // smart_contracts/session/contract.py:66
    // self.next_token_id = self.next_token_id + UInt64(1)
    intc_0 // 0
    bytec 5 // "next_token_id"
    app_global_get_ex
    assert // check self.next_token_id exists
    intc_1 // 1
    +
    bytec 5 // "next_token_id"
    swap
    app_global_put
    // smart_contracts/session/contract.py:46
    // @abimethod()
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.burn[routing]() -> void:
burn:
    // smart_contracts/session/contract.py:70
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/session/contract.py:76
    // assert Txn.sender == self.current_owner, "Only owner can burn NFT"
    txn Sender
    intc_0 // 0
    bytec_2 // "current_owner"
    app_global_get_ex
    assert // check self.current_owner exists
    ==
    assert // Only owner can burn NFT
    // smart_contracts/session/contract.py:77
    // assert token_id == self.current_token_id, "Invalid token ID"
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    ==
    assert // Invalid token ID
    // smart_contracts/session/contract.py:78
    // assert self.total_supply > UInt64(0), "No NFTs to burn"
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    assert // No NFTs to burn
    // smart_contracts/session/contract.py:80-81
    // # Update state
    // self.current_owner = Account()  # Reset to zero address
    bytec_2 // "current_owner"
    global ZeroAddress
    app_global_put
    // smart_contracts/session/contract.py:82
    // self.current_token_id = UInt64(0)
    bytec_1 // "current_token_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/session/contract.py:83
    // self.total_supply = self.total_supply - UInt64(1)
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    intc_1 // 1
    -
    bytec_0 // "total_supply"
    swap
    app_global_put
    // smart_contracts/session/contract.py:70
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.transfer[routing]() -> void:
transfer:
    // smart_contracts/session/contract.py:85
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/session/contract.py:90
    // assert Txn.sender == self.current_owner, "Only owner can transfer NFT"
    txn Sender
    intc_0 // 0
    bytec_2 // "current_owner"
    app_global_get_ex
    assert // check self.current_owner exists
    swap
    dig 1
    ==
    assert // Only owner can transfer NFT
    // smart_contracts/session/contract.py:91
    // assert to != Account(), "Cannot transfer to zero address"
    dig 2
    global ZeroAddress
    !=
    assert // Cannot transfer to zero address
    // smart_contracts/session/contract.py:92
    // assert token_id == self.current_token_id, "Invalid token ID"
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    uncover 2
    ==
    assert // Invalid token ID
    // smart_contracts/session/contract.py:93
    // assert to != self.current_owner, "Cannot transfer to same address"
    dig 1
    !=
    assert // Cannot transfer to same address
    // smart_contracts/session/contract.py:95-96
    // # Update ownership
    // self.current_owner = to
    bytec_2 // "current_owner"
    swap
    app_global_put
    // smart_contracts/session/contract.py:85
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.transfer_from[routing]() -> void:
transfer_from:
    // smart_contracts/session/contract.py:98
    // @abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/session/contract.py:103
    // assert from_account == self.current_owner, "From account is not the owner"
    intc_0 // 0
    bytec_2 // "current_owner"
    app_global_get_ex
    assert // check self.current_owner exists
    dig 3
    ==
    assert // From account is not the owner
    // smart_contracts/session/contract.py:104
    // assert to != Account(), "Cannot transfer to zero address"
    global ZeroAddress
    uncover 2
    !=
    assert // Cannot transfer to zero address
    // smart_contracts/session/contract.py:105
    // assert token_id == self.current_token_id, "Invalid token ID"
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    ==
    assert // Invalid token ID
    // smart_contracts/session/contract.py:106
    // assert Txn.sender == from_account or Txn.sender == self.minter, "Not authorized to transfer"
    txn Sender
    ==
    bnz transfer_from_bool_true@3
    txn Sender
    intc_0 // 0
    bytec 4 // "minter"
    app_global_get_ex
    assert // check self.minter exists
    ==
    bz transfer_from_bool_false@4

transfer_from_bool_true@3:
    intc_1 // 1

transfer_from_bool_merge@5:
    // smart_contracts/session/contract.py:106
    // assert Txn.sender == from_account or Txn.sender == self.minter, "Not authorized to transfer"
    assert // Not authorized to transfer
    // smart_contracts/session/contract.py:107
    // assert to != from_account, "Cannot transfer to same address"
    dupn 2
    dig 3
    !=
    assert // Cannot transfer to same address
    // smart_contracts/session/contract.py:109-110
    // # Update ownership
    // self.current_owner = to
    bytec_2 // "current_owner"
    swap
    app_global_put
    // smart_contracts/session/contract.py:98
    // @abimethod()
    intc_1 // 1
    return

transfer_from_bool_false@4:
    intc_0 // 0
    b transfer_from_bool_merge@5


// smart_contracts.session.contract.SimpleNFT.balance_of[routing]() -> void:
balance_of:
    // smart_contracts/session/contract.py:112
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/session/contract.py:118
    // assert account != Account(), "Zero address has no balance"
    dup
    global ZeroAddress
    !=
    assert // Zero address has no balance
    // smart_contracts/session/contract.py:120
    // if account == self.current_owner and self.total_supply > UInt64(0):
    intc_0 // 0
    bytec_2 // "current_owner"
    app_global_get_ex
    assert // check self.current_owner exists
    ==
    bz balance_of_after_if_else@4
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    bz balance_of_after_if_else@4
    // smart_contracts/session/contract.py:121
    // return UInt64(1)
    intc_1 // 1

balance_of_after_inlined_smart_contracts.session.contract.SimpleNFT.balance_of@5:
    // smart_contracts/session/contract.py:112
    // @abimethod()
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

balance_of_after_if_else@4:
    // smart_contracts/session/contract.py:122
    // return UInt64(0)
    intc_0 // 0
    // smart_contracts/session/contract.py:112
    // @abimethod()
    b balance_of_after_inlined_smart_contracts.session.contract.SimpleNFT.balance_of@5


// smart_contracts.session.contract.SimpleNFT.owner_of[routing]() -> void:
owner_of:
    // smart_contracts/session/contract.py:124
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/session/contract.py:129
    // assert token_id == self.current_token_id, "Invalid token ID"
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    ==
    assert // Invalid token ID
    // smart_contracts/session/contract.py:130
    // assert self.total_supply > UInt64(0), "NFT does not exist"
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    assert // NFT does not exist
    // smart_contracts/session/contract.py:132
    // return self.current_owner
    intc_0 // 0
    bytec_2 // "current_owner"
    app_global_get_ex
    assert // check self.current_owner exists
    // smart_contracts/session/contract.py:124
    // @abimethod()
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.get_name[routing]() -> void:
get_name:
    // smart_contracts/session/contract.py:137
    // return self.token_name
    intc_0 // 0
    bytec 6 // "token_name"
    app_global_get_ex
    assert // check self.token_name exists
    // smart_contracts/session/contract.py:134
    // @abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.get_symbol[routing]() -> void:
get_symbol:
    // smart_contracts/session/contract.py:142
    // return self.token_symbol
    intc_0 // 0
    bytec 7 // "token_symbol"
    app_global_get_ex
    assert // check self.token_symbol exists
    // smart_contracts/session/contract.py:139
    // @abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.get_uri[routing]() -> void:
get_uri:
    // smart_contracts/session/contract.py:144
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/session/contract.py:147
    // assert token_id == self.current_token_id, "Invalid token ID"
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    ==
    assert // Invalid token ID
    // smart_contracts/session/contract.py:148
    // return self.token_uri
    intc_0 // 0
    bytec 8 // "token_uri"
    app_global_get_ex
    assert // check self.token_uri exists
    // smart_contracts/session/contract.py:144
    // @abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.get_total_supply[routing]() -> void:
get_total_supply:
    // smart_contracts/session/contract.py:153
    // return self.total_supply
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    // smart_contracts/session/contract.py:150
    // @abimethod()
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.set_minter[routing]() -> void:
set_minter:
    // smart_contracts/session/contract.py:155
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/session/contract.py:160
    // assert Txn.sender == self.minter, "Only current minter can set new minter"
    txn Sender
    intc_0 // 0
    bytec 4 // "minter"
    app_global_get_ex
    assert // check self.minter exists
    swap
    dig 1
    ==
    assert // Only current minter can set new minter
    // smart_contracts/session/contract.py:161
    // assert new_minter != Account(), "Cannot set minter to zero address"
    dig 1
    global ZeroAddress
    !=
    assert // Cannot set minter to zero address
    // smart_contracts/session/contract.py:162
    // assert new_minter != self.minter, "New minter must be different"
    dig 1
    !=
    assert // New minter must be different
    // smart_contracts/session/contract.py:164
    // self.minter = new_minter
    bytec 4 // "minter"
    swap
    app_global_put
    // smart_contracts/session/contract.py:155
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.get_current_token_id[routing]() -> void:
get_current_token_id:
    // smart_contracts/session/contract.py:169
    // return self.current_token_id
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    // smart_contracts/session/contract.py:166
    // @abimethod()
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.session.contract.SimpleNFT.exists[routing]() -> void:
exists:
    // smart_contracts/session/contract.py:171
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/session/contract.py:174
    // return token_id == self.current_token_id and self.total_supply > UInt64(0)
    intc_0 // 0
    bytec_1 // "current_token_id"
    app_global_get_ex
    assert // check self.current_token_id exists
    ==
    bz exists_bool_false@4
    intc_0 // 0
    bytec_0 // "total_supply"
    app_global_get_ex
    assert // check self.total_supply exists
    bz exists_bool_false@4
    intc_1 // 1

exists_bool_merge@5:
    // smart_contracts/session/contract.py:171
    // @abimethod()
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

exists_bool_false@4:
    intc_0 // 0
    b exists_bool_merge@5
